[{"title":"Git 使用A","url":"/2025/08/08/Git-%E4%BD%BF%E7%94%A8A/","content":"假设你已经登录了 Gitee ，用户名为 Mikisana 并且新建了一个叫 mikisana 的仓库（repository）。\n不妨再假设你的电脑上已经有了一个叫 git 的软件。\n下面就是最基础的操作。\nGit 设置在每台电脑上都设置一次即可。\ngit config --global user.name &quot;Mikisana&quot;git config --global user.email &quot;*****@**.com&quot;\n\n创建仓库进入文件目录用下面的方法在终端进入特定文件夹。\n例如，你所有的文件都在 D:/mikisana/ 下。\ncd D:/mikisana\n\n或者打开文件夹，在上方路径框输入 powershell。\n\n接着你会看到这个：\n\n下面的命令默认在 D:/mikisana 进行。\n仓库初始化这一步，只在第一次执行！只在 第一台 电脑上执行一次！\n建立仓库：\ngit init\n\n在 第二或更多台 电脑的第一次，你需要（前提是你已经有了提交）：\n进入 D:/\ngit clone git@gitee.com:mikisana/mikisana.git\n\n接着会出现 mikisana 这个文件夹，后面进入即可。\n日常维护更新至最新只要你提交过，并且更换了电脑，就需要这一步。\ngit pull origin master\n\n接下来正常进行编辑，然后再提交。\n提交在需要保存的时候这样做：\ngit add .git commit -m &quot;some message to describe this commit&quot;\n\n\n上面 add 后面有一个点，这是通配符，指所有文件\n也就是说，在这个文件夹中的所有文件都会被提交\n如果你不想保留某些或某类文件，可以用 .gitignore 文件配置\n例如，加入一行 *.exe 就不会保留所有 exe 文件\n再如，加入一行 tmp/ 不会保留当前目录下，一个叫 tmp 的文件夹中的文件\n\n刚刚只是本地的保存，要提交你 还需要：\ngit push -u origin master\n\n只在 第一台 电脑的 第一次 加上 -u！！\n可能的问题输入 git 找不到命令安装 git 不到位，没有加入环境变量。\n提交失败使用 ssh 连接，需要建立密钥。\n生成 SSH 密钥打开你的 Git powershell，输入以下命令，并将 your_email@example.com 替换成你注册 GitHub 时用的邮箱。\nssh-keygen -t rsa -C &quot;your_email@example.com&quot;\n\n之后会提示你输入文件保存位置，直接按 Enter 键使用默认位置即可。\n接着会提示你输入密码（passphrase），为了方便，你可以直接按 Enter 键留空（即无密码）。再次确认时再按一次 Enter。\n部署 SSH 密钥找到并复制你的公钥。公钥文件通常在 C:\\Users\\你的用户名\\.ssh\\id_rsa.pub。你可以用以下命令在 Powershell 中直接显示并复制它：\ncat ~/.ssh/id_rsa.pub\n\n登录你的 Gitee 账户，点击右上角的头像 -&gt; Settings，在左侧菜单中，点击 SSH and GPG keys，点击 New SSH key 按钮。\nTitle 随便起一个名字，比如 My Blog PC，在 Key 文本框中，粘贴你刚刚复制的公钥内容，点击 Add SSH key。\n\nGit 是一个强大的版本控制工具，它的功能还远不止于此。\n","categories":["介绍"],"tags":["奇技淫巧"]},{"title":"Hexo|Redefine 博客搭建","url":"/2025/08/06/Hexo-Redefine-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","content":"这是一个非常详细的、手把手的教程，教你如何使用 Hexo + Redefine 主题在 GitHub Pages 上搭建你的个人博客。\n我们将整个过程分为以下几个主要步骤：\n\n准备工作：安装必要软件\n本地搭建：初始化 Hexo 博客\nGitHub 配置：创建代码仓库\n关联与部署：将本地博客推送到 GitHub\n主题配置：安装并启用 Redefine 主题\n内容管理：添加文章、标签、分类和归档页面\n日常维护：写作与发布流程总结\n\n\n第一步：准备工作 (环境搭建)在开始之前，你的电脑需要安装以下软件：\nGit 用于版本控制和部署代码到 GitHub下载地址：https://git-scm.com/downloads\n安装时一路点击 “Next” 即可。安装后，在终端（Windows 用户推荐使用 Git Bash）中输入 git --version，如果显示版本号则表示安装成功。\nNode.js Hexo 是基于 Node.js 的，所以必须安装它。下载地址：https://nodejs.org/\n请下载 LTS (长期支持) 版本。安装时同样一路 “Next”。安装后，在终端中输入 node -v 和 npm -v，如果都显示版本号则表示安装成功。\n\n第二步：本地搭建 Hexo 博客安装 Hexo CLI (命令行工具)打开你的终端（或 Git Bash），输入以下命令进行全局安装：\nnpm install -g hexo-cli\n\n初始化博客项目选择一个你喜欢的文件夹来存放你的博客文件，比如 D:\\Blog。在该目录下打开终端，然后执行：\n# &quot;my-blog&quot; 是你的博客文件夹名，可以自定义hexo init my-blog\n\n等待命令执行完毕，Hexo 会自动创建一个名为 my-blog 的文件夹，并下载所有必要文件。\n进入博客目录并安装依赖cd my-blognpm install\n\n本地预览现在，你的博客已经在本地准备就绪了。运行以下命令启动本地服务器：\nhexo server# 或者简写为 hexo s\n启动后，终端会提示：\nHexo is running at http://localhost:4000/ . Press Ctrl+C to stop.\n在浏览器中打开 http://localhost:4000，你就能看到 Hexo 的默认博客页面了。这表示本地环境已成功！ 按 Ctrl+C 可以关闭本地服务器。\n第三步：GitHub 配置注册 GitHub 账户如果你还没有，先去 GitHub 官网 注册一个账户。\n创建博客仓库 (Repository)这是最关键的一步，仓库名必须符合特定格式：\n点击 GitHub 页面右上角的 + 号，选择 New repository。\nRepository name 必须设置为：username.github.io。\n\n例如，如果你的 GitHub 用户名是 zhangsan，那么仓库名就是 zhangsan.github.io。\n\n选择 Public (公开)。\n不要勾选 “Add a README file” 等任何选项，保持一个空仓库。\n点击 Create repository。\n添加 SSH 密钥生成 SSH 密钥打开你的 Git Bash，输入以下命令，并将 your_email@example.com 替换成你注册 GitHub 时用的邮箱。\nssh-keygen -t rsa -C &quot;your_email@example.com&quot;\n\n之后会提示你输入文件保存位置，直接按 Enter 键使用默认位置即可。\n接着会提示你输入密码（passphrase），为了方便，你可以直接按 Enter 键留空（即无密码）。再次确认时再按一次 Enter。\n部署 SSH 密钥找到并复制你的公钥。公钥文件通常在 C:\\Users\\你的用户名\\.ssh\\id_rsa.pub。你可以用以下命令在 Git Bash 中直接显示并复制它：\ncat ~/.ssh/id_rsa.pub\n\n登录你的 GitHub 账户，点击右上角的头像 -&gt; Settings，在左侧菜单中，点击 SSH and GPG keys，点击 New SSH key 按钮。\nTitle 随便起一个名字，比如 My Blog PC，在 Key 文本框中，粘贴你刚刚复制的公钥内容，点击 Add SSH key。\n测试连接在 Git Bash 中输入以下命令：\nssh -T git@github.com\n\n你可能会看到一个警告，问你是否信任这个主机，输入 yes 并按 Enter。如果一切顺利，你会看到这样的成功信息：\n\nHi InfinityKI! You&#39;ve successfully authenticated, but GitHub does not provide shell access.\n\n这表明你的 SSH 连接已经成功建立！\n第四步：关联与部署安装 Git 部署插件在你的博客根目录 (my-blog) 的终端中，安装一个插件，让 Hexo 能通过 Git 进行部署。\nnpm install hexo-deployer-git --save\n\n配置站点 _config.yml 文件打开你博客根目录下的 _config.yml 文件（注意不是主题文件夹里的），找到 deploy 部分（通常在文件末尾），修改成如下格式：\n# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: git  repo: git@github.com:username/uername.github.io.git  branch: main # 或者 master，取决于你的 GitHub 默认分支名\n\n提示: repo 地址可以在你刚刚创建的 GitHub 仓库页面上找到（点击 “Code” 按钮）。一定使用 SSH 格式的地址。\n生成并部署现在，让我们把本地的博客内容部署到 GitHub 上。\n# 清理旧文件（可选，但推荐）hexo clean# 生成静态文件hexo generate# 或者简写为 hexo g# 部署到 GitHubhexo deploy# 或者简写为 hexo d\n\n执行 hexo deploy 时，可能会弹窗让你输入 GitHub 的用户名和密码（或者 Token，如果你开启了2FA）。\n部署成功后，等待几分钟，访问 https://username.github.io，就能看到和本地一模一样的博客了！\n第五步：安装并启用 Redefine 主题下载 Redefine 主题在你的博客根目录 (my-blog) 的终端中，执行以下命令将主题克隆到 themes 文件夹下：\ngit clone https://github.com/EvanNotFound/hexo-theme-redefine.git themes/redefine\n\n启用主题再次打开博客根目录下的 _config.yml 文件，找到 theme 字段，将其值从 landscape 修改为 redefine：\n# Extensions  ## Plugins: https://hexo.io/plugins/  ## Themes: https://hexo.io/themes/  theme: redefine\n\n配置文件你会在 my-blog/_config.yaml 中找到一些信息，这些信息可以及时修改。包括接下来在 redefine 主题文件夹中也有这样的文件，里面的内容需要你的修改。\n你可以根据 Redefine 主题官方文档 来修改 _config.redefine.yml 以进行个性化定制.\n下面是我本人的样例。\n重新生成和预览保存所有修改后，重新执行：\nhexo clean &amp;&amp; hexo g &amp;&amp; hexo s\n\n现在访问 http://localhost:4000，你应该能看到全新的 Redefine 主题界面了！\n更新保存所有修改后，重新执行：\nhexo clean &amp;&amp; hexo g &amp;&amp; hexo d\n\n每次你做出修改，都应在本地预览后执行这样的命令，来同步到你的 github 上\n第六步：内容管理（文章、标签、分类、归档）这是你日常使用最多的部分。\n添加新文章命令：在博客根目录的终端中执行：\nhexo new &quot;我的第一篇文章&quot;\n\n文件位置：命令执行后，会在 source/_posts/ 目录下生成一个 我的第一篇文章.md 文件。\n编辑文章：打开这个 .md 文件，你会看到类似下面的内容：\n---title: 我的第一篇文章date: 2023-10-27 15:30:00tags:    - tag1    - tag2categories:    - cate_f    - cate_s--这里是你的正文内容，使用 Markdown 语法书写...\n\n--- 包围的部分叫做 Front-matter，用于配置文章信息。\n注意：分类具有层级关系，[cate_f, cate_s] 会被解析为 cate_f -&gt; cate_s 的分类。标签则是平级的。\n创建归档、标签和分类的专属页面默认情况下，这些页面是不存在的，需要手动创建。\n创建页面文件在博客根目录的终端中，依次执行以下命令：\nhexo new page &quot;tags&quot;hexo new page &quot;categories&quot;\n\n这会在 source 目录下创建对应的文件夹，如 source/archives/、source/tags/ 等，每个文件夹里都有一个 index.md 文件。\n修改页面文件内容打开 source/tags/index.md，修改为：\n---title: 标签date: 2023-10-27 16:01:00template: tags---\n\n打开 source/categories/index.md，修改为：\n---title: 类别date: 2023-10-27 16:02:00template: categories---\n\n在导航菜单中显示这些页面这些详细内容应该在 [导航栏](导航栏 navbar | Hexo Theme Redefine Docs)\n或者\n[主页侧边栏](首页文章 home | Hexo Theme Redefine Docs)\n第七步：日常维护流程恭喜你，博客已经完全搭建好了！今后你的日常操作就是：\n写新文章hexo new &quot;新文章标题&quot;\n\n编辑 Markdown 文件在 source/_posts/ 中找到文件，添加内容、标签和分类。\n本地预览hexo clean; hexo g; hexo s\n\n在浏览器 localhost:4000 检查效果。\n部署到线上确认无误后，按 Ctrl+C 停止本地服务，然后执行：\nhexo clean &amp;&amp; hexo g &amp;&amp; hexo d\n\n等待几分钟，全世界就都能看到你的新文章了！\n\n小提示：\n如果你和我一样，本地看起来非常好，然而提交至 github 出现了问题，尝试 shift+F5 强制刷新。\n\n\n一些小插件下面的内容，都需要 \nnpm install package-name\n\nMathjax 数学公式安装插件在 Hexo 项目根目录下安装插件 hexo-filter-mathjax，请执行如下命令\nnpm install hexo-filter-mathjax\n修改配置文件在 Hexo 配置文件 _config.yml 最底下增加如下配置。\nmathjax:    tags: none # or &#x27;ams&#x27; or &#x27;all&#x27;    single_dollars: true # enable single dollar signs as in-line math delimiters    cjk_width: 0.9 # relative CJK char width    normal_width: 0.6 # relative normal (monospace) width    append_css: true # add CSS to every page    every_page: false # if true, every page will be rendered by mathjax regardless the `mathjax` s\n\n搜索安装插件npm install hexo-generator-searchdb --save\n\n开关配置项名称：search.enable\n\n\n\n类型\n可选值\n默认值\n\n\n\n布尔值\ntrue | false\nfalse\n\n\n","categories":["介绍"],"tags":["奇技淫巧"]},{"title":"抗维生素D佝偻病","url":"/2025/08/17/%E6%8A%97%E7%BB%B4%E7%94%9F%E7%B4%A0D%E4%BD%9D%E5%81%BB%E7%97%85/","content":"\n遗传方式 (Inheritance Pattern)抗维生素D佝偻病是一组疾病的总称，其最常见的类型是 X连锁低磷血症性佝偻病 (X-linked hypophosphatemia, XLH)，约占所有病例的80%以上。\n主要遗传方式：X连锁显性遗传 (X-linked Dominant Inheritance)致病基因： 位于X染色体上的 PHEX 基因突变是导致XLH的主要原因。这个基因的功能是调节一种叫做“成纤维细胞生长因子23 (FGF23)”的激素。基因突变后，FGF23水平异常升高。\n遗传特点\n父亲患病： 他的所有 女儿 都会患病（因为女儿会从父亲那里得到唯一的X染色体），但所有 儿子 都不会患病（因为儿子从父亲那里得到的是Y染色体）。\n母亲患病： 她的 儿子和女儿 都有 50% 的概率患病（因为母亲有两条X染色体，会随机遗传其中一条给子女）。\n性别差异： 通常情况下，男性的症状会比女性更严重一些，因为男性只有一条X染色体，没有另一条正常的X染色体来“补偿”。\n新发突变： 约有20-30%的患者并没有家族史，属于自身基因新发突变导致。\n其他罕见遗传方式常染色体显性遗传性低磷血症性佝偻病 (ADH R)：由 FGF23 基因突变引起。\n常染色体隐性遗传性低磷血症性佝偻病 (ARHR)：由 DMP1 或 ENPP1 等基因突变引起。\n发病率 (Incidence&#x2F;Prevalence)抗维生素D佝偻病属于 罕见病。\n最常见的类型XLH，其全球发病率约为 1&#x2F;20,000 至 1&#x2F;25,000。这意味着每两万到两万五千个新生儿中，大约会有一个患有此病。\n\n症状表现 (Clinical Manifestations)该病的核心问题是肾脏无法正常重吸收磷，导致血液中磷的水平过低（低磷血症），进而影响骨骼的正常矿化。\n儿童期主要症状骨骼畸形： 这是最典型的症状。通常在孩子开始走路后（1-2岁）变得明显。\n\n“O”型腿（膝内翻）或“X”型腿（膝外翻）。\n身材矮小，生长迟缓。\n手腕、脚踝等关节增宽，形成“佝偻病手镯&#x2F;脚镯”。\n前额突出，形成“方颅”。\n肋骨与软骨连接处增厚，形成“佝偻病串珠”。\n\n骨骼疼痛： 特别是在腿部和关节处。\n牙齿问题： 牙釉质发育不全，容易出现牙脓肿、牙痛和过早掉牙。\n肌肉无力： 走路姿势异常（摇摆步态）。\n成年期主要症状骨软化症 (Osteomalacia)： 骨骼矿化不足，导致骨骼疼痛、假性骨折（应力性骨折）。\n关节炎： 特别是脊柱和下肢关节的骨关节炎。\n骨赘形成： 韧带和肌腱附着点钙化，导致关节僵硬和疼痛。\n听力受损： 部分患者可能出现听力下降。\n牙齿问题持续存在。\n与普通佝偻病的区别最大的区别在于 病因。普通佝偻病是由于缺乏维生素D或钙，通过补充维生素D和钙可以治愈。而抗维生素D佝偻病是基因缺陷，补充普通剂量的维生素D 无效。\n\n预防和治疗措施 (Prevention and Treatment)预防 (Prevention)遗传咨询： 对于有家族史的家庭，遗传咨询至关重要。医生可以帮助他们了解该病的遗传风险、生育选择等。\n产前诊断： 对于高风险的孕妇，可以通过羊膜腔穿刺或绒毛取样等技术，对胎儿进行基因检测，实现产前诊断。\n\n（严格来说，作为一种遗传病，无法像预防传染病那样“预防”，这里的“预防”更多指通过遗传学手段避免疾病在后代中发生或及早干预。）\n\n治疗 (Treatment)治疗目标是纠正低磷血症，促进骨骼正常生长和矿化，减轻症状。\n传统治疗方案（常规治疗）口服磷酸盐溶液： 每天需多次服用，以补充流失的磷。这是治疗的基石。\n活性维生素D（如骨化三醇、阿法骨化醇）： 配合磷酸盐使用。它的作用是促进肠道对磷和钙的吸收，并抑制甲状旁腺功能亢进（这是低磷血症的常见并发症）。\n挑战： 传统治疗需要终身服药，每天多次，依从性差。且可能带来肾结石、肾钙化等副作用。\n靶向治疗：基于病理生理机制的干预该方案旨在从源头阻断疾病的发生机制。\n核心病理机制：FGF23水平异常升高在XLH患者体内，因 PHEX 基因突变，骨细胞不受控制地大量分泌FGF23。过量的FGF23作用于肾脏，产生两大核心病理效应：\n\n抑制肾脏重吸收磷：导致大量磷从尿液中流失，造成低磷血症。\n抑制活性维生素D生成：进一步减少了肠道对磷和钙的吸收。\n\n靶向药物：布罗索单抗 (Burosumab)布罗索单抗是一种人源化抗FGF23单克隆抗体。其作用机制如下：\n\n精准结合：在血液中，布罗索单抗能够特异性地识别并结合过量的FGF23分子。\n阻断信号：通过结合，它能阻止FGF23与其在肾脏的受体结合，从而阻断其病理信号。\n恢复功能：肾脏对磷的重吸收能力得以恢复，血磷浓度回升至正常水平；同时活性维生素D的生成也恢复正常。\n\n治疗模式的革新与传统疗法相比，布罗索单抗实现了治疗理念的根本性转变。\n\n\n\n对比维度\n传统疗法 (磷酸盐+活性VD)\n靶向治疗 (布罗索单抗)\n\n\n\n作用层面\n下游补充 (补充流失的磷)\n上游阻断 (中和核心致病因子FGF23)\n\n\n血磷控制\n波动大，呈“峰谷”状\n稳定、持续维持在生理范围内\n\n\n治疗效果\n佝偻病愈合不完全，生长改善有限\n显著促进佝偻病愈合，改善骨骼畸形和生长\n\n\n给药方式\n每日3-5次口服\n每2-4周一次皮下注射\n\n\n生活质量\n依从性差，严重影响日常生活\n极大提高依从性和生活质量\n\n\n安全性\n存在肾钙化、肾结石风险\n肾脏相关并发症风险低\n\n\n总结而言，布罗索单抗的问世标志着XLH的治疗从被动的“对症补充”进入了主动的“对因干预”时代，从根本上纠正了疾病的内分泌紊乱。\n","categories":["报告"]},{"title":"有些小秘密","url":"/2025/08/06/%E6%9C%89%E4%BA%9B%E5%B0%8F%E7%A7%98%E5%AF%86/","content":"\n\n  e16df09abbb65805c82caebd51880abeba6d6e684a828d1f8702399b9787c8f669992d9332b90e2ce378ef8e3291756db9a9bf9bc2cddeb26d5fc9602825fbd99b7d3a6cb7b4878a08bf9f79e4a7ebb55fbff8b27b12b2a26ad39e30fb73654ad7823c8b05c3944a1df4d15318a10172\n  \n    \n      \n      \n        Hey, password is required here.\n      \n    \n  \n\n\n\nimport {initHBE} from \"/js/plugins/hbe.js\";\n  console.log(\"hexo-blog-encrypt: loaded.\");\n    initHBE();\n\n"},{"title":"容斥原理和二项式反演","url":"/2025/08/06/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86%E5%92%8C%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/","content":"容斥原理 (Principle of Inclusion-Exclusion, PIE)容斥原理是用来解决“并集计数”问题的核心工具。它的基本思想是：为了求几个集合并集的大小，我们先把所有集合的大小加起来，然后减去被重复计算的（两个集合的交集），再加上被错误减去的（三个集合的交集），再减去…如此往复，一加一减，直到最后。\n直观理解\n两个集合： \n\n解释： 中， 的部分被计算了两次，所以要减掉一次。\n\n\n三个集合： \n\n解释：\n先加上所有单个集合的大小。\n这时，两两相交的部分被多算了一次，所以全部减掉。\n但这样一来，三个集合共同相交的部分  被加了3次（在中），又被减了3次（在中），等于一次都没算。所以最后要把它加回来。\n\n\n\n\n\n一般形式假设我们有  个性质（或集合）。我们想要求至少满足其中一个性质的元素个数。这等价于求集合  的大小，其中  是具有性质  的元素构成的集合。\n公式：\n更紧凑的求和形式：\n\n 是下标集合  的一个非空子集。\n 是子集  的大小（即交集的个数）。\n 表示子集  中所有下标对应的集合的交集。\n\n“一个都不满足”的形式（更常用）在很多问题中，我们想求的是一个性质都不满足的元素个数。设全集为 。那么所求的就是：代入容斥原理公式得到：\n更紧凑的形式：（约定 ，即空交集为全集）\n经典应用：错排问题 (Derangements)问题： 封信和  个对应的信封，将所有信随机装入信封，求每封信都未装入正确信封的方案数 。\n解法：\n\n全集 U：所有可能的排列，共  种。\n性质 ：第  封信装入了正确的信封。\n集合 ：满足性质  的排列的集合。\n目标：求一个性质都不满足的方案数，即 。\n\n应用容斥原理：\n\n = \n：考虑 ，即第  封信在正确位置。剩下的  封信可以任意排列，有  种方案。一共有  个这样的集合，所以这项是 。\n：考虑 ，即第  和第  封信都在正确位置。剩下的  封信任意排列，有  种方案。我们从  个位置中选2个，有  种选法。所以这项是 。\n通项： 个集合的交集大小为 。\n\n代入公式：化简 ，得到：这就是著名的错排公式。\n\n二项式反演 (Binomial Inversion)二项式反演是一种代数工具，它揭示了两个序列之间通过二项式系数建立的一种对偶关系。它常用于解决“恰好”与“至少/至多”之间的转换问题。\n公式形式设有两个序列  和 。\n形式一（“至多”形式）：如果那么\n形式二（“至少”形式，更常用）：如果为上限那么\n理解  和  的含义这是理解和应用二项式反演的关键。\n\n 通常代表“恰好有  个元素/满足  个性质”的方案数。\n 通常代表一个与  相关、但更容易计算的量。常见的含义是：\n在形式一中， 通常是与“个元素构成的子集”相关的某种总和。\n在形式二中， 通常是“至少有  个元素/满足  个性质”的方案数。\n\n\n\n“至少”的解释：为什么  代表“至少”？考虑一个有“至少  个性质”的方案。假设它恰好有  个性质（）。那么这个方案在计算  时，会被计算多少次呢？我们从它拥有的这  个性质中，任选  个，都满足“至少有n个性质”的条件，所以它被计算了  次。因此，把所有恰好有  个性质的方案（ 种）贡献的次数加起来，就是 。\n应用：再解错排问题我们用二项式反演来求 。\n\n：恰好有  个位置正确的排列数。我们的目标是 。\n：钦定（指定）  个位置是正确的，其余位置任意排列的方案数。这比“至少”更容易计算。\n如何计算 ？从  个位置中选  个作为正确的位置，有  种选法。剩下的  个位置任意排列，有  种方案。\n所以，。\n\n\n\n建立  和  的关系：我们使用“至少”形式的变体。一个“钦定”了  个位置正确的方案，可能实际上有更多位置是正确的。可以证明（这正是二项式反演的威力），它们满足关系：（这个关系和我们之前推导“至少”的逻辑是一样的）\n进行反演：根据二项式反演公式（形式二），我们有：\n求我们的目标 ：令 ，则：因为 ，且 ，代入得：我们得到了和容斥原理完全相同的结果！\n二项式反演的证明证明所需的核心恒等式在开始之前，我们需要一个关键的组合恒等式。对于整数 ：\n这里的  是艾佛森括号 (Iverson bracket)，表示：\n\n如果 ，表达式的值为 1。\n如果 ，表达式的值为 0。\n\n证明这个恒等式：\n\n首先，对二项式系数进行展开：\n\n我们可以重新组合这个式子：这个变换非常有用：先从n个里选k个，再从剩下的n-k个里选i-k个。\n\n将这个结果代入原求和式：\n\n由于  与求和变量  无关，可以提到前面：\n\n进行换元，令 。当  时，；当  时，。\n\n现在我们来分析这个求和。根据二项式定理：令 , , ，则：\n\n分析求和结果：\n\n如果  (即 )，那么 。\n如果  (即 )，那么 。（约定  在组合数学中是标准做法）\n\n\n所以，。\n\n代回第4步的式子：\n\n如果 ，值为 。\n\n\n如果 ，值为 。这正是  的定义。\n\n\n\n恒等式证毕。现在我们可以用它来证明二项式反演了。\n\n证明形式一已知：式求证：式\n证明过程：\n我们将 (式1) 代入 (式2) 的右边，然后化简，目标是得到 。\n\n从 (式2) 的右边开始：\n\n将  的定义 (式1) 代入，注意 (式1) 中的求和上限是 ，变量是 ：\n\n这是一个双重求和。我们可以交换求和次序。原始的求和范围是 。交换次序后，我们先对  求和，再对  求和。 的范围是  到 。对于一个固定的 ， 的范围是  到 。\n\n将与内层求和变量  无关的  提出来：\n\n应用核心恒等式，将这个结果代回第4步：这个求和中，只有当  时， 才为1，其余项都为0。所以整个和只剩下  这一项：\n\n\n这就证明了 (式2) 成立。\n\n证明形式二这个形式在组合计数中更常用。\n已知：式求证：式\n证明过程：\n同样，我们将 (式3) 代入 (式4) 的右边。\n\n从 (式4) 的右边开始：\n\n将  的定义 (式3) 代入。注意 (式3) 的求和变量是 ，下限是 ：\n\n交换求和次序。原始的求和范围是 。交换后，我们先对  求和，再对  求和。 的范围是  到 。对于一个固定的 ， 的范围是  到 。\n\n将与内层求和变量  无关的  提出来：\n\n现在，我们聚焦于括号内的求和。这正是我们最开始证明的核心恒等式！对照核心恒等式 。这里的  对应于 ， 对应于 ， 对应于 。令恒等式中的 , , 。\n\n将这个结果代回第4步：这个求和中，只有当  时， 才为1，其余项都为0。所以整个和只剩下  这一项：\n\n\n这就证明了 (式4) 成立。\n总结容斥原理与二项式反演的关系它们是解决同一类问题的不同视角：\n\n容斥原理是基于集合论的，通过对集合的交、并进行操作，处理“至少一个”和“一个都无”的问题。它的公式形式本身就带有交替的符号。\n二项式反演是基于代数的，它是一个关于序列的恒等式。它将难求的“恰好”问题，转化为易求的“钦定”或“至少”问题，然后通过公式反解。\n\n在很多问题中，容斥原理的每一步计算（例如 ）都对应着二项式反演中  的计算。可以说，二项式反演是容斥原理的一种代数抽象和推广。\n\n\n\n特性\n容斥原理\n二项式反演\n\n\n\n基础\n集合论\n代数学\n\n\n核心思想\n对重复计算的部分进行加减校正\n建立“恰好”与“至少/钦定”之间的代数关系，然后反解\n\n\n解决问题\n求并集大小，或“至少一个”/“一个都无”的问题\n求“恰好k个”的问题\n\n\n公式外观\n交替加减集合交集的大小\n两个序列通过二项式系数和交替符号联系\n\n\n联系\n二项式反演可以看作是容斥原理的代数形式和推广\n是容斥原理的代数形式，也是更广义的莫比乌斯反演的特例\n\n\n掌握这两个工具，并理解它们之间的深层联系，将极大地提升你解决复杂组合计数问题的能力。\n推广：莫比乌斯反演 (Möbius Inversion)二项式反演本身是更广义的莫比乌斯反演在特定偏序集上的一个特例。\n\n莫比乌斯反演是定义在**偏序集（Poset）**上的一个泛用性极强的反演关系。\n二项式反演是莫比乌斯反演在**“集合包含关系”**这个偏序集上的体现。\n另一个著名的数论莫比乌斯反演，是其在**“整除关系”**这个偏序集上的体现。\n\n理解莫比우스反演可以让你从一个更高的维度俯视这些反演技巧，认识到它们共享着相同的底层数学结构。\nMin-Max 容斥 (Min-Max Inclusion-Exclusion)核心思想：Max 与 Min 的相互转换Min-Max 容斥提供了一种令人惊奇的能力：将一个集合的最大值 (max)，用该集合所有子集的最小值 (min) 来表示；反之亦然。\n这为什么有用？在很多问题中，直接计算一个集合中多个随机变量的最大值的期望 (E[max]) 可能非常困难，因为这些变量往往不是独立的。然而，计算它们最小值的期望 (E[min]) 可能要简单得多。Min-Max 容斥搭起了两者之间的桥梁。\n基本公式设  是一个由数值（或随机变量）组成的有限集合。\n1. 用 min 表示 max集合  的最大值等于其所有非空子集的最小值的交替和：\n\n展开形式（以3个元素为例）：对于 :由于 ，上式即为：\n2. 用 max 表示 min集合  的最小值等于其所有非空子集的最大值的交替和：\n\n展开形式（以3个元素为例）：对于 :\n观察：这两个公式的结构与标准的容斥原理完全一致！\n证明过程我们来证明第一个公式：max(S) = ...。证明的思路是一种经典的组合计数思想：我们不直接证明等式两边相等，而是证明集合  中的每一个元素在右侧的式子中被计算的总系数，恰好使得最终结果为 max(S)。\n\n准备工作：将集合  的元素从大到小排序，设为 。那么，。我们的目标是证明右侧的交替和  的结果也等于 。\n\n分析贡献：考虑任意一个元素 。我们来计算它在整个式子中的总贡献，也就是它的最终系数。元素  会在哪些项  中出现？当且仅当  时， 才对这一项的值有贡献。\n\n确定条件： 的充要条件是：\n\n 必须在子集  中。\n所有比  小的元素 () 都不能在子集  中。\n 中的其他元素只能从比  大的元素 () 中选取。\n\n\n计算系数：符合上述条件的子集  必须由  和一个从 （这个集合有  个元素）中选出的子集  构成。即 。我们枚举  的大小，设 ，其中  可以从  到 。\n\n当  时，子集  的大小为 。\n从  个元素中选出  个元素构成 ，有  种选法。\n每一种这样的选法，对应的项是 。\n\n所以， 的总系数是所有这些情况的系数之和：\n\n应用二项式定理：这个求和式正是二项式定理  的一个特例。令 ，我们得到：\n\n分情况讨论：\n\n对于  (即  不是最大的元素 )：，所以 。这意味着，除了最大元素之外的所有元素  的最终系数都是0！它们对总和没有任何贡献。\n对于  (即  是最大的元素 )：，所以 。（在组合数学中，约定 ）这意味着，最大元素  的最终系数是 1。\n\n\n结论：在整个交替和中，只有  的系数是 1，其他所有元素的系数都是 0。所以，整个式子的值就是 。而 。证明完毕。\n\n\n期望形式 (最强大的应用)Min-Max 容斥最强大的地方在于它可以直接应用于期望。因为期望具有线性性 ()，我们可以将期望算子直接应用到公式的每一项。\n设  是一个由随机变量组成的集合 。\n\n这个公式是解决一类经典概率问题的杀手锏。\n经典应用：优惠券收集问题 (Coupon Collector’s Problem)问题：假设有  种不同的优惠券，每次购买商品会随机获得一种。问集齐所有  种优惠券所需购买商品次数的期望是多少？\n解法：\n\n定义随机变量：设  是获得第  种优惠券所需的购买次数。\n目标：我们要求的是集齐所有优惠券的次数，这等价于所有  中的最大值。即求 。\n困难点： 之间不是独立的，直接求  非常困难。\n应用 Min-Max 容斥：其中 。\n计算子问题 ： 是什么意思？它是指在子集  所代表的那些优惠券中，第一次获得其中任意一种所需的购买次数的期望。设 。这意味着我们的目标是获得这  种优惠券中的任何一种。在每次购买时，成功的概率（即抽到这  种中的一种）是 。这是一个典型的几何分布问题。对于成功概率为  的几何分布，其期望是 。所以，。\n代回原式：注意到  的值只取决于子集  的大小 ，而与具体是哪些元素无关。对于一个固定的 （），大小为  的子集  共有  个。所以，我们可以按子集大小  来分组求和：其中这就是优惠券收集问题的期望值的精确公式。（这个结果可以进一步化简，恰好等于 ，即  乘以调和级数，但 Min-Max 容斥直接给出了这个交替和形式的解）。\n\n扩展：k-th Min-Max 容斥Min-Max 容斥还有一个更广义的形式，可以用来求第  大（或第  小）的元素。\n设  表示集合  中第  大的元素。\n验证一下：当  时，求最大值（第1大）：。这与我们最初的 max 公式完全一致。\n同样，这个公式也适用于期望。\n总结\n核心功能：在 max 和 min 之间建立一个基于容斥原理的代数转换。\n结构：与标准容斥原理的公式结构完全相同。\n证明：通过分析每个元素在求和式中的总系数来证明，利用了二项式定理 。\n最强应用：期望形式 ，特别适用于求解多个非独立随机变量最大值的期望，能将一个困难问题分解为一系列简单的子问题。\n推广：存在 k-th Min-Max 形式，可以求解第  大/小的值。\n\n","categories":["笔记"],"tags":["数学"]},{"title":"稀土","url":"/2025/08/17/%E7%A8%80%E5%9C%9F/","content":"课题： 稀土（Rare Earths）研究方式： 文献研究\n引言稀土元素（Rare Earth Elements, REE）是元素周期表中钪（Sc）、钇（Y）以及镧系（Lanthanides）共17种金属元素的总称。它们虽名为“稀土”，但部分元素的地壳丰度并不低，其“稀有”主要在于其矿物分散，且难以从矿石中分离提纯成单一金属。稀土因其独特的光、电、磁、催化等物理化学性质，被誉为“工业的维生素”和“新材料的宝库”，在现代工业、高新技术和国防科技中扮演着不可或缺的角色。本报告旨在阐述稀土冶炼的基本化学原理、其广泛应用以及新型冶炼技术的发展趋势。\n一、 稀土冶炼的基本化学原理稀土的冶炼过程极其复杂，其核心挑战在于将化学性质极为相似的17种元素从共生矿中逐一分离并提纯。整个流程大致可分为四个主要步骤：\n1. 选矿富集这是物理过程，目的是提高矿石中稀土的品位。主要方法包括浮选法、重选法和磁选法。通过这些方法，将含有稀土的矿物（如氟碳铈矿、独居石）与脉石（如石英、方解石）分离开，得到稀土精矿。\n\n2. 分解浸出（化学分解）这是将稀土从精矿的晶格中“解放”出来，使其进入溶液或转化为易于处理的化合物。主要有两种主流工艺\n酸法分解常用浓硫酸或盐酸在高温下处理精矿。\n硫酸焙烧法（以氟碳铈矿为例）：将精矿与浓硫酸混合焙烧，使稀土元素转化为可溶于水的硫酸盐，而矿物中的氟则以氟化氢（HF）气体形式逸出。\n\nREOF·CaCO₃ (矿) + H₂SO₄ (浓) → RE₂(SO₄)₃ (可溶) + CaSO₄ (沉淀) + H₂O + CO₂↑ + HF↑\n（注：此为简化反应式，实际过程非常复杂）\n后续用水浸出，稀土硫酸盐进入溶液，实现与杂质的分离。\n\n碱法分解常用浓氢氧化钠（NaOH）溶液在高温高压下处理精矿（如独居石）。\n\nREPO₄ (矿) + NaOH (浓) → RE(OH)₃ (沉淀) + Na₃PO₄ (可溶)\n此方法将稀土转化为氢氧化物沉淀，而矿物中的磷酸根则进入溶液，从而实现分离。\n\n3. 分离提纯这是稀土冶炼技术含量最高、最关键的环节。由于镧系元素原子结构相似（电子层结构仅在4f轨道有差异），导致它们的化学性质非常接近，分离极为困难。\n稀土分组的化学原理基于硫酸复盐溶解度的分组： 这是一个经典的化学分离前处理步骤。根据稀土元素与硫酸钠（或铵）形成的复盐在水溶液中溶解度的显著差异，可以将混合稀土预先分成三个组：\n\n铈组（轻稀土）： 硫酸复盐难溶，会沉淀下来。\n铽组（中稀土）： 硫酸复盐微溶。\n钇组（重稀土）： 硫酸复盐易溶，留在溶液中。 这个原理是工业上进行粗分离、降低后续精细分离（如溶剂萃取）压力的重要依据。\n\n基于萃取酸度的分组： 文章指出了使用特定萃取剂（如P204）时，通过控制溶液的酸度，可以优先萃取不同的稀土组。\n\n轻稀土： 在弱酸条件下被萃取。\n中、重稀土： 需要在更低的酸度（即更高的pH值）下才能被有效萃取。这揭示了溶剂萃取法的核心操作机理之一——通过“调酸”来选择性地“钓”出不同的稀土鱼。\n\n分步法利用化合物在溶剂中溶解度的差别进行分离提纯的方式称为分步法。\n从钇(Y)到镥(Lu)，所有天然存在的稀土元素间的单一分离，包括居里夫妇发现的镭，都是用这种方法分离的。此方法操作程序较为复杂，全部稀土元素的单一分离耗费了100多年，一次分离重复操作竟达2万次，对于化学工作者而言，其工作强度较大，过程较为复杂。因此用这样的方法不能大量生产单一稀土。\n离子交换法原理：利用稀土离子与离子交换树脂结合能力的差异。将稀土混合溶液通过填充了树脂的交换柱，然后用特定的洗脱剂（如EDTA）进行淋洗，结合能力弱的稀土离子会先被洗脱下来，从而实现分离。此方法成本较高，通常用于制备高纯度稀土产品。\n溶剂萃取法（主流技术）这是目前应用最广泛、最成熟的分离技术。\n原理：利用不同稀土离子在水相和有机相（萃取剂）之间分配系数的微小差异，通过成百上千次的重复萃取（串级萃取），像“筛豆子”一样，将不同的稀土元素逐一分离。\n过程：将含有多种稀土离子的水溶液与一种有机溶剂（如P507萃取剂溶于磺化煤油）混合。某些稀土离子更容易与萃取剂结合而进入有机相，另一些则留在水相。通过多级萃取器（如混合澄清槽），最终可以得到高纯度的单一稀土溶液。\n4. 金属制备将分离提纯后的高纯度稀土化合物（如氧化物、氯化物、氟化物）还原为金属单质。\n熔盐电解法主要用于制备熔点较低的轻稀土金属（如镧、铈、钕）\n原理：在高温下，电解熔融的稀土氯化物或氧化物。以电解熔融氯化钕（NdCl₃）为例：\n\n阴极：Nd³⁺ + 3e⁻ → Nd (金属钕)\n阳极：2Cl⁻ - 2e⁻ → Cl₂↑ (氯气)\n\n电解法有 氯化物 电解和 氧化物 电解两种方法。\n氯化物电解是生产金属最普通的方法，特别是混合稀土金属工艺简单，成本便宜，投资小，但最大缺点是氯气放出，污染环境。氧化物电解没有有害气体放出，但成本稍高些，一般生产价格较高的单一稀土如钕、镨等都用氧化物电解。\n金属热还原法主要用于制备熔点高、活性强的中重稀土金属（如钐、铽、镝）\n原理：利用比稀土更活泼的金属（如钙、锂）在高温真空条件下，将其从氟化物或氧化物中还原出来。\n\n2DyF₃ + 3Ca --(高温)--&gt; 2Dy + 3CaF₂\n\n二、 稀土金属的应用稀土的应用领域极其广泛，是支撑现代高新技术产业发展的关键战略材料。\n\n\n\n应用领域\n具体应用及相关稀土元素\n作用与价值\n\n\n\n高新技术与新材料\n永磁材料： 钕铁硼（NdFeB）永磁体，含钕(Nd)、镨(Pr)、镝(Dy)、铽(Tb)。\n被誉为“磁王”，是电机、风力发电机、电动汽车、智能手机、硬盘驱动器的核心部件，实现设备小型化、轻量化和高效能。\n\n\n\n发光材料： LED、荧光灯、显示屏中的荧光粉。主要使用铕(Eu，发红光)、铽(Tb，发绿光)、铈(Ce)、钇(Y)。\n实现高效率、高色彩还原度的照明和显示技术，是节能照明和高清显示屏的基础。\n\n\n\n储氢材料： 储氢合金，如镧镍（LaNi₅）合金，主要含镧(La)。\n用于镍氢电池（混合动力汽车电池），安全、高效地储存和释放氢气。\n\n\n\n催化材料： 石油裂化催化剂、汽车尾气净化器。主要使用镧(La)、铈(Ce)。\n提高汽油产率，有效转化汽车尾气中的有害气体（CO、NOx），保护环境。\n\n\n\n抛光材料： 高纯氧化铈（CeO₂）。\n用于精密光学玻璃、摄像头镜头、手机屏幕的高精度抛光，是信息产业不可或缺的耗材。\n\n\n国防与航空航天\n特种合金： 添加到钢、铝、镁合金中，含**钇(Y)、钪(Sc)、钆(Gd)**等。\n显著提高材料的强度、韧性、耐高温和抗腐蚀性能，用于制造战斗机、导弹、航空发动机部件。\n\n\n\n激光与传感： 掺钕钇铝石榴石（Nd:YAG）激光器，光纤，精确制导。\n军事激光武器、激光测距、光纤通信、导弹制导系统的核心材料。\n\n\n医疗与生活\n医疗影像： 核磁共振（MRI）造影剂，主要含钆(Gd)。\n增强成像对比度，帮助医生更清晰地诊断病变。\n\n\n\n玻璃陶瓷： 作为添加剂。**铈(Ce)**可使玻璃脱色，**钕(Nd)**可使玻璃呈紫色。\n制造特种光学玻璃（如相机镜头），以及赋予陶瓷漂亮的色彩。\n\n\n农业\n稀土肥料： 稀土微量元素肥料。\n促进植物生长，提高作物产量和抗逆性。\n\n\n三、 新型冶炼技术的发展及展望传统稀土冶炼技术（特别是酸碱法分解和溶剂萃取）虽然成熟，但也面临着能耗高、化学试剂消耗大、产生大量酸碱废水和含放射性废渣等严重的环境问题。因此，研发绿色、高效的新型冶炼技术是未来的必然趋势。\n发展方向\n绿色化： 减少或消除污染物的产生。例如，使用更环保的萃取剂（如离子液体）替代挥发性有机溶剂；开发无氨皂化、无皂化萃取等清洁分离技术，从源头减少氨氮废水的产生。\n高效化： 提高分离效率，缩短流程。例如，研究新型高效萃取剂和萃取设备，以及将多种分离技术（如萃取色谱法）联用，实现对特定稀土元素的快速精准分离。\n智能化： 利用自动化控制和大数据分析，精确控制萃取过程的各项参数，提高产品质量和稳定性，降低人力成本。\n循环化（城市采矿）： 从废旧电子产品（如硬盘磁体、荧光灯粉）中回收稀土，是解决资源短缺和环境污染的重要途径。开发高效、低成本的稀土回收技术是当前的研究热点。\n\n前沿技术展望\n超临界流体萃取： 利用超临界二氧化碳（SC-CO₂）作为萃取剂，其无毒、不燃、易于分离，是一种极具潜力的绿色分离技术。\n功能化材料吸附法： 设计和合成能够特异性识别并吸附某种稀土离子的新材料（如分子印迹聚合物、功能化纳米材料），实现“一步式”的高选择性分离。\n生物冶金： 利用特定微生物的代谢活动来浸出和富集稀土元素，这种方法环境友好、成本低，但目前尚处于实验室研究阶段。\n熔融氧化物电解（MOE）： 直接电解稀土氧化物来制备金属，省去了将其氯化或氟化的步骤，过程更短，且副产品是氧气，非常清洁。这是颠覆性的下一代技术，但技术难度极高。\n\n","categories":["报告"]},{"title":"组合数","url":"/2025/08/17/%E7%BB%84%E5%90%88%E6%95%B0/","content":"初始化我们知道阶乘的定义：  (i+1)! = i! * (i+1)\n现在，我们对这个等式的两边同时取模逆元。根据模逆元的性质 inv(a * b) = inv(a) * inv(b) (mod p)，我们得到：  inv((i+1)!) = inv(i!) * inv(i+1)\n我们的目标是求 inv(i!)。所以，我们把上面的等式变形，两边同时乘以 (i+1)：  inv((i+1)!) * (i+1) = inv(i!) * inv(i+1) * (i+1)\n因为一个数乘以它自己的逆元等于 1（inv(x) * x ≡ 1 (mod p)），所以等式右边的 inv(i+1) * (i+1) 就等于 1。于是我们得到了最终的关键递推关系：\ninv(i!) = inv((i+1)!) * (i+1)\n这个公式告诉我们：如果我们知道了 inv((i+1)!)，我们就可以用一次乘法 O(1) 的时间复杂度计算出 inv(i!)。\nconst int MAXN = 355;const int MOD = 1e9 + 7;int n;ll fact[MAXN], invfact[MAXN];inline ll quick_pow(ll a, ll k) {    ll ret = 1;    while (k) {        if (k &amp; 1)            ret = ret * a % MOD;        k &gt;&gt;= 1;        a = a * a % MOD;    }    return ret;}inline ll inv(ll x) {    return quick_pow(x, MOD - 2);}inline void init(int limit) {    fact[0] = 1;    invfact[0] = 1;    for (int i = 1; i &lt;= limit; ++i) {        fact[i] = (fact[i - 1] * i) % MOD;    }    invfact[limit] = inv(fact[limit]);    for (int i = limit - 1; i &gt;= 1; --i) {        invfact[i] = (invfact[i + 1] * (i + 1)) % MOD;    }}inline ll C(int n_items, int m_choices) {    if (m_choices &lt; 0 || m_choices &gt; n_items)        return 0;    return fact[n_items] * invfact[m_choices] % MOD * invfact[n_items - m_choices] % MOD;}int main() {\tcin &gt;&gt; n;\tinit(n);}","categories":["笔记"],"tags":["数学"]},{"title":"费马小定理和逆元","url":"/2025/08/06/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86%E5%92%8C%E9%80%86%E5%85%83/","content":"费马小定理若  为素数，，则 。\n逆元引入我们知道，在实数域中，一个数 a 的倒数是 a⁻¹，因为 a * a⁻¹ = 1。除以一个数 b 就等价于乘以 b 的倒数，即 a / b = a * (b⁻¹)。\n在模运算的世界里，我们想做类似的事情。对于一个整数 a 和一个模数 p，我们想找到一个整数 x，使得 (a * x) % p = 1。如果找到了这样的 x，我们就称 x 是 a 在模 p 意义下的 乘法逆元，记作 a⁻¹。\n有了逆元，我们就可以在模 p 的意义下做除法了： (a / b) % p 就变成了 (a * b⁻¹) % p\n重要前提：a 在模 p 意义下存在逆元的充要条件是 a 和 p 互质，即 gcd(a, p) = 1。\n定义若 ，则称  为  的逆元\n当且仅当  时，逆元存在。\n快速幂法\n要求  为 素数\n\n根据费马小定理，。\n则 ，即  为  的逆元\nll mod;ll quick_power(ll a, ll k) {    ll res = 1;    while (k) {        if (k &amp; 1)            res = res * a % mod;        a = a * a % mod;        k &gt;&gt;= 1;    }    return res;}inline ll inv(ll x) {    return quick_power(x, mod-2);}\n\n线性方法记 inv[i] 为  的逆元。\n\n即 inv[i] = (p - p / i) * inv[p % i] % p\nll mod;ll inv[MAXN];void init(){    inv[1] = 1;    for (int i = 2; i &lt;= mod; ++i)        inv[i] = (mod - mod / i) * inv[mod % i] % p;}\n\n性质设  为  的逆元，则 \n卢卡斯定理\n要求  为 素数\n\n对于素数 ，有 \n即\nll mod;ll fact[MAX_MOD];  // 阶乘ll inv(int x);     // 逆元ll C(ll m, ll n) {    if (m &gt; mod || n &gt; mod)        return C(m / mod, n / mod) * C(m % mod, n % mod) % mod;    return fact[n] * inv(fact[m]) * inv(fact[n - m]) % mod;}\n","categories":["笔记"],"tags":["数学"]}]