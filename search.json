[{"title":"Hexo|Redefine 博客搭建","url":"/2025/08/06/Hexo-Redefine-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","content":"这是一个非常详细的、手把手的教程，教你如何使用 Hexo + Redefine 主题在 GitHub Pages 上搭建你的个人博客。\n我们将整个过程分为以下几个主要步骤：\n\n准备工作：安装必要软件\n本地搭建：初始化 Hexo 博客\nGitHub 配置：创建代码仓库\n关联与部署：将本地博客推送到 GitHub\n主题配置：安装并启用 Redefine 主题\n内容管理：添加文章、标签、分类和归档页面\n日常维护：写作与发布流程总结\n\n\n第一步：准备工作 (环境搭建)在开始之前，你的电脑需要安装以下软件：\nGit 用于版本控制和部署代码到 GitHub下载地址：https://git-scm.com/downloads\n安装时一路点击 “Next” 即可。安装后，在终端（Windows 用户推荐使用 Git Bash）中输入 git --version，如果显示版本号则表示安装成功。\nNode.js Hexo 是基于 Node.js 的，所以必须安装它。下载地址：https://nodejs.org/\n请下载 LTS (长期支持) 版本。安装时同样一路 “Next”。安装后，在终端中输入 node -v 和 npm -v，如果都显示版本号则表示安装成功。\n\n第二步：本地搭建 Hexo 博客安装 Hexo CLI (命令行工具)打开你的终端（或 Git Bash），输入以下命令进行全局安装：\nnpm install -g hexo-cli\n\n初始化博客项目选择一个你喜欢的文件夹来存放你的博客文件，比如 D:\\Blog。在该目录下打开终端，然后执行：\n# &quot;my-blog&quot; 是你的博客文件夹名，可以自定义hexo init my-blog\n\n等待命令执行完毕，Hexo 会自动创建一个名为 my-blog 的文件夹，并下载所有必要文件。\n进入博客目录并安装依赖cd my-blognpm install\n\n本地预览现在，你的博客已经在本地准备就绪了。运行以下命令启动本地服务器：\nhexo server# 或者简写为 hexo s\n启动后，终端会提示：\nHexo is running at http://localhost:4000/ . Press Ctrl+C to stop.\n在浏览器中打开 http://localhost:4000，你就能看到 Hexo 的默认博客页面了。这表示本地环境已成功！ 按 Ctrl+C 可以关闭本地服务器。\n第三步：GitHub 配置注册 GitHub 账户如果你还没有，先去 GitHub 官网 注册一个账户。\n创建博客仓库 (Repository)这是最关键的一步，仓库名必须符合特定格式：\n点击 GitHub 页面右上角的 + 号，选择 New repository。\nRepository name 必须设置为：username.github.io。\n\n例如，如果你的 GitHub 用户名是 zhangsan，那么仓库名就是 zhangsan.github.io。\n\n选择 Public (公开)。\n不要勾选 “Add a README file” 等任何选项，保持一个空仓库。\n点击 Create repository。\n添加 SSH 密钥生成 SSH 密钥打开你的 Git Bash，输入以下命令，并将 your_email@example.com 替换成你注册 GitHub 时用的邮箱。\nssh-keygen -t rsa -C &quot;your_email@example.com&quot;\n\n之后会提示你输入文件保存位置，直接按 Enter 键使用默认位置即可。\n接着会提示你输入密码（passphrase），为了方便，你可以直接按 Enter 键留空（即无密码）。再次确认时再按一次 Enter。\n部署 SSH 密钥找到并复制你的公钥。公钥文件通常在 C:\\Users\\你的用户名\\.ssh\\id_rsa.pub。你可以用以下命令在 Git Bash 中直接显示并复制它：\ncat ~/.ssh/id_rsa.pub\n\n登录你的 GitHub 账户，点击右上角的头像 -&gt; Settings，在左侧菜单中，点击 SSH and GPG keys，点击 New SSH key 按钮。\nTitle 随便起一个名字，比如 My Blog PC，在 Key 文本框中，粘贴你刚刚复制的公钥内容，点击 Add SSH key。\n测试连接在 Git Bash 中输入以下命令：\nssh -T git@github.com\n\n你可能会看到一个警告，问你是否信任这个主机，输入 yes 并按 Enter。如果一切顺利，你会看到这样的成功信息：\n\nHi InfinityKI! You&#39;ve successfully authenticated, but GitHub does not provide shell access.\n\n这表明你的 SSH 连接已经成功建立！\n第四步：关联与部署安装 Git 部署插件在你的博客根目录 (my-blog) 的终端中，安装一个插件，让 Hexo 能通过 Git 进行部署。\nnpm install hexo-deployer-git --save\n\n配置站点 _config.yml 文件打开你博客根目录下的 _config.yml 文件（注意不是主题文件夹里的），找到 deploy 部分（通常在文件末尾），修改成如下格式：\n# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: git  repo: git@github.com:username/uername.github.io.git  branch: main # 或者 master，取决于你的 GitHub 默认分支名\n\n提示: repo 地址可以在你刚刚创建的 GitHub 仓库页面上找到（点击 “Code” 按钮）。一定使用 SSH 格式的地址。\n生成并部署现在，让我们把本地的博客内容部署到 GitHub 上。\n# 清理旧文件（可选，但推荐）hexo clean# 生成静态文件hexo generate# 或者简写为 hexo g# 部署到 GitHubhexo deploy# 或者简写为 hexo d\n\n执行 hexo deploy 时，可能会弹窗让你输入 GitHub 的用户名和密码（或者 Token，如果你开启了2FA）。\n部署成功后，等待几分钟，访问 https://username.github.io，就能看到和本地一模一样的博客了！\n第五步：安装并启用 Redefine 主题下载 Redefine 主题在你的博客根目录 (my-blog) 的终端中，执行以下命令将主题克隆到 themes 文件夹下：\ngit clone https://github.com/EvanNotFound/hexo-theme-redefine.git themes/redefine\n\n启用主题再次打开博客根目录下的 _config.yml 文件，找到 theme 字段，将其值从 landscape 修改为 redefine：\n# Extensions  ## Plugins: https://hexo.io/plugins/  ## Themes: https://hexo.io/themes/  theme: redefine\n\n配置文件你会在 my-blog/_config.yaml 中找到一些信息，这些信息可以及时修改。包括接下来在 redefine 主题文件夹中也有这样的文件，里面的内容需要你的修改。\n你可以根据 Redefine 主题官方文档 来修改 _config.redefine.yml 以进行个性化定制.\n下面是我本人的样例。\n重新生成和预览保存所有修改后，重新执行：\nhexo clean &amp;&amp; hexo g &amp;&amp; hexo s\n\n现在访问 http://localhost:4000，你应该能看到全新的 Redefine 主题界面了！\n更新保存所有修改后，重新执行：\nhexo clean &amp;&amp; hexo g &amp;&amp; hexo d\n\n每次你做出修改，都应在本地预览后执行这样的命令，来同步到你的 github 上\n第六步：内容管理（文章、标签、分类、归档）这是你日常使用最多的部分。\n添加新文章命令：在博客根目录的终端中执行：\nhexo new &quot;我的第一篇文章&quot;\n\n文件位置：命令执行后，会在 source/_posts/ 目录下生成一个 我的第一篇文章.md 文件。\n编辑文章：打开这个 .md 文件，你会看到类似下面的内容：\n---title: 我的第一篇文章date: 2023-10-27 15:30:00tags:    - tag1    - tag2categories:    - cate_f    - cate_s--这里是你的正文内容，使用 Markdown 语法书写...\n\n--- 包围的部分叫做 Front-matter，用于配置文章信息。\n注意：分类具有层级关系，[cate_f, cate_s] 会被解析为 cate_f -&gt; cate_s 的分类。标签则是平级的。\n创建归档、标签和分类的专属页面默认情况下，这些页面是不存在的，需要手动创建。\n创建页面文件在博客根目录的终端中，依次执行以下命令：\nhexo new page &quot;tags&quot;hexo new page &quot;categories&quot;\n\n这会在 source 目录下创建对应的文件夹，如 source/archives/、source/tags/ 等，每个文件夹里都有一个 index.md 文件。\n修改页面文件内容打开 source/tags/index.md，修改为：\n---title: 标签date: 2023-10-27 16:01:00template: tags---\n\n打开 source/categories/index.md，修改为：\n---title: 类别date: 2023-10-27 16:02:00template: categories---\n\n在导航菜单中显示这些页面这些详细内容应该在 [导航栏](导航栏 navbar | Hexo Theme Redefine Docs)\n或者\n[主页侧边栏](首页文章 home | Hexo Theme Redefine Docs)\n第七步：日常维护流程恭喜你，博客已经完全搭建好了！今后你的日常操作就是：\n写新文章hexo new &quot;新文章标题&quot;\n\n编辑 Markdown 文件在 source/_posts/ 中找到文件，添加内容、标签和分类。\n本地预览hexo clean; hexo g; hexo s\n\n在浏览器 localhost:4000 检查效果。\n部署到线上确认无误后，按 Ctrl+C 停止本地服务，然后执行：\nhexo clean &amp;&amp; hexo g &amp;&amp; hexo d\n\n等待几分钟，全世界就都能看到你的新文章了！\n\n小提示：\n如果你和我一样，本地看起来非常好，然而提交至 github 出现了问题，尝试 shift+F5 强制刷新。\n\n\n一些小插件下面的内容，都需要 \nnpm install package-name\n\nMathjax 数学公式安装插件在 Hexo 项目根目录下安装插件 hexo-filter-mathjax，请执行如下命令\nnpm install hexo-filter-mathjax\n修改配置文件在 Hexo 配置文件 _config.yml 最底下增加如下配置。\nmathjax:    tags: none # or &#x27;ams&#x27; or &#x27;all&#x27;    single_dollars: true # enable single dollar signs as in-line math delimiters    cjk_width: 0.9 # relative CJK char width    normal_width: 0.6 # relative normal (monospace) width    append_css: true # add CSS to every page    every_page: false # if true, every page will be rendered by mathjax regardless the `mathjax` s\n\n搜索安装插件npm install hexo-generator-searchdb --save\n\n开关配置项名称：search.enable\n\n\n\n类型\n可选值\n默认值\n\n\n\n布尔值\ntrue | false\nfalse\n\n\n","tags":["奇技淫巧"]},{"title":"有些小秘密","url":"/2025/08/06/%E6%9C%89%E4%BA%9B%E5%B0%8F%E7%A7%98%E5%AF%86/","content":"\n\n  e16df09abbb65805c82caebd51880abeba6d6e684a828d1f8702399b9787c8f669992d9332b90e2ce378ef8e3291756db9a9bf9bc2cddeb26d5fc9602825fbd99b7d3a6cb7b4878a08bf9f79e4a7ebb55fbff8b27b12b2a26ad39e30fb73654ad7823c8b05c3944a1df4d15318a10172\n  \n    \n      \n      \n        Hey, password is required here.\n      \n    \n  \n\n\n\nimport {initHBE} from \"/js/plugins/hbe.js\";\n  console.log(\"hexo-blog-encrypt: loaded.\");\n    initHBE();\n\n"},{"title":"容斥原理和二项式反演","url":"/2025/08/06/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86%E5%92%8C%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/","content":"容斥原理 (Principle of Inclusion-Exclusion, PIE)容斥原理是用来解决“并集计数”问题的核心工具。它的基本思想是：为了求几个集合并集的大小，我们先把所有集合的大小加起来，然后减去被重复计算的（两个集合的交集），再加上被错误减去的（三个集合的交集），再减去…如此往复，一加一减，直到最后。\n直观理解\n两个集合： \n\n解释： 中， 的部分被计算了两次，所以要减掉一次。\n\n\n三个集合： \n\n解释：\n先加上所有单个集合的大小。\n这时，两两相交的部分被多算了一次，所以全部减掉。\n但这样一来，三个集合共同相交的部分  被加了3次（在中），又被减了3次（在中），等于一次都没算。所以最后要把它加回来。\n\n\n\n\n\n一般形式假设我们有  个性质（或集合）。我们想要求至少满足其中一个性质的元素个数。这等价于求集合  的大小，其中  是具有性质  的元素构成的集合。\n公式：\n更紧凑的求和形式：\n\n 是下标集合  的一个非空子集。\n 是子集  的大小（即交集的个数）。\n 表示子集  中所有下标对应的集合的交集。\n\n“一个都不满足”的形式（更常用）在很多问题中，我们想求的是一个性质都不满足的元素个数。设全集为 。那么所求的就是：代入容斥原理公式得到：\n更紧凑的形式：（约定 ，即空交集为全集）\n经典应用：错排问题 (Derangements)问题： 封信和  个对应的信封，将所有信随机装入信封，求每封信都未装入正确信封的方案数 。\n解法：\n\n全集 U：所有可能的排列，共  种。\n性质 ：第  封信装入了正确的信封。\n集合 ：满足性质  的排列的集合。\n目标：求一个性质都不满足的方案数，即 。\n\n应用容斥原理：\n\n = \n：考虑 ，即第  封信在正确位置。剩下的  封信可以任意排列，有  种方案。一共有  个这样的集合，所以这项是 。\n：考虑 ，即第  和第  封信都在正确位置。剩下的  封信任意排列，有  种方案。我们从  个位置中选2个，有  种选法。所以这项是 。\n通项： 个集合的交集大小为 。\n\n代入公式：化简 ，得到：这就是著名的错排公式。\n\n二项式反演 (Binomial Inversion)二项式反演是一种代数工具，它揭示了两个序列之间通过二项式系数建立的一种对偶关系。它常用于解决“恰好”与“至少/至多”之间的转换问题。\n公式形式设有两个序列  和 。\n形式一（“至多”形式）：如果那么\n形式二（“至少”形式，更常用）：如果为上限那么\n理解  和  的含义这是理解和应用二项式反演的关键。\n\n 通常代表“恰好有  个元素/满足  个性质”的方案数。\n 通常代表一个与  相关、但更容易计算的量。常见的含义是：\n在形式一中， 通常是与“个元素构成的子集”相关的某种总和。\n在形式二中， 通常是“至少有  个元素/满足  个性质”的方案数。\n\n\n\n“至少”的解释：为什么  代表“至少”？考虑一个有“至少  个性质”的方案。假设它恰好有  个性质（）。那么这个方案在计算  时，会被计算多少次呢？我们从它拥有的这  个性质中，任选  个，都满足“至少有n个性质”的条件，所以它被计算了  次。因此，把所有恰好有  个性质的方案（ 种）贡献的次数加起来，就是 。\n应用：再解错排问题我们用二项式反演来求 。\n\n：恰好有  个位置正确的排列数。我们的目标是 。\n：钦定（指定）  个位置是正确的，其余位置任意排列的方案数。这比“至少”更容易计算。\n如何计算 ？从  个位置中选  个作为正确的位置，有  种选法。剩下的  个位置任意排列，有  种方案。\n所以，。\n\n\n\n建立  和  的关系：我们使用“至少”形式的变体。一个“钦定”了  个位置正确的方案，可能实际上有更多位置是正确的。可以证明（这正是二项式反演的威力），它们满足关系：（这个关系和我们之前推导“至少”的逻辑是一样的）\n进行反演：根据二项式反演公式（形式二），我们有：\n求我们的目标 ：令 ，则：因为 ，且 ，代入得：我们得到了和容斥原理完全相同的结果！\n二项式反演的证明证明所需的核心恒等式在开始之前，我们需要一个关键的组合恒等式。对于整数 ：\n这里的  是艾佛森括号 (Iverson bracket)，表示：\n\n如果 ，表达式的值为 1。\n如果 ，表达式的值为 0。\n\n证明这个恒等式：\n\n首先，对二项式系数进行展开：\n\n我们可以重新组合这个式子：这个变换非常有用：先从n个里选k个，再从剩下的n-k个里选i-k个。\n\n将这个结果代入原求和式：\n\n由于  与求和变量  无关，可以提到前面：\n\n进行换元，令 。当  时，；当  时，。\n\n现在我们来分析这个求和。根据二项式定理：令 , , ，则：\n\n分析求和结果：\n\n如果  (即 )，那么 。\n如果  (即 )，那么 。（约定  在组合数学中是标准做法）\n\n\n所以，。\n\n代回第4步的式子：\n\n如果 ，值为 。\n\n\n如果 ，值为 。这正是  的定义。\n\n\n\n恒等式证毕。现在我们可以用它来证明二项式反演了。\n\n证明形式一已知：式求证：式\n证明过程：\n我们将 (式1) 代入 (式2) 的右边，然后化简，目标是得到 。\n\n从 (式2) 的右边开始：\n\n将  的定义 (式1) 代入，注意 (式1) 中的求和上限是 ，变量是 ：\n\n这是一个双重求和。我们可以交换求和次序。原始的求和范围是 。交换次序后，我们先对  求和，再对  求和。 的范围是  到 。对于一个固定的 ， 的范围是  到 。\n\n将与内层求和变量  无关的  提出来：\n\n应用核心恒等式，将这个结果代回第4步：这个求和中，只有当  时， 才为1，其余项都为0。所以整个和只剩下  这一项：\n\n\n这就证明了 (式2) 成立。\n\n证明形式二这个形式在组合计数中更常用。\n已知：式求证：式\n证明过程：\n同样，我们将 (式3) 代入 (式4) 的右边。\n\n从 (式4) 的右边开始：\n\n将  的定义 (式3) 代入。注意 (式3) 的求和变量是 ，下限是 ：\n\n交换求和次序。原始的求和范围是 。交换后，我们先对  求和，再对  求和。 的范围是  到 。对于一个固定的 ， 的范围是  到 。\n\n将与内层求和变量  无关的  提出来：\n\n现在，我们聚焦于括号内的求和。这正是我们最开始证明的核心恒等式！对照核心恒等式 。这里的  对应于 ， 对应于 ， 对应于 。令恒等式中的 , , 。\n\n将这个结果代回第4步：这个求和中，只有当  时， 才为1，其余项都为0。所以整个和只剩下  这一项：\n\n\n这就证明了 (式4) 成立。\n总结容斥原理与二项式反演的关系它们是解决同一类问题的不同视角：\n\n容斥原理是基于集合论的，通过对集合的交、并进行操作，处理“至少一个”和“一个都无”的问题。它的公式形式本身就带有交替的符号。\n二项式反演是基于代数的，它是一个关于序列的恒等式。它将难求的“恰好”问题，转化为易求的“钦定”或“至少”问题，然后通过公式反解。\n\n在很多问题中，容斥原理的每一步计算（例如 ）都对应着二项式反演中  的计算。可以说，二项式反演是容斥原理的一种代数抽象和推广。\n\n\n\n特性\n容斥原理\n二项式反演\n\n\n\n基础\n集合论\n代数学\n\n\n核心思想\n对重复计算的部分进行加减校正\n建立“恰好”与“至少/钦定”之间的代数关系，然后反解\n\n\n解决问题\n求并集大小，或“至少一个”/“一个都无”的问题\n求“恰好k个”的问题\n\n\n公式外观\n交替加减集合交集的大小\n两个序列通过二项式系数和交替符号联系\n\n\n联系\n二项式反演可以看作是容斥原理的代数形式和推广\n是容斥原理的代数形式，也是更广义的莫比乌斯反演的特例\n\n\n掌握这两个工具，并理解它们之间的深层联系，将极大地提升你解决复杂组合计数问题的能力。\n推广：莫比乌斯反演 (Möbius Inversion)二项式反演本身是更广义的莫比乌斯反演在特定偏序集上的一个特例。\n\n莫比乌斯反演是定义在**偏序集（Poset）**上的一个泛用性极强的反演关系。\n二项式反演是莫比乌斯反演在**“集合包含关系”**这个偏序集上的体现。\n另一个著名的数论莫比乌斯反演，是其在**“整除关系”**这个偏序集上的体现。\n\n理解莫比우스反演可以让你从一个更高的维度俯视这些反演技巧，认识到它们共享着相同的底层数学结构。\nMin-Max 容斥 (Min-Max Inclusion-Exclusion)核心思想：Max 与 Min 的相互转换Min-Max 容斥提供了一种令人惊奇的能力：将一个集合的最大值 (max)，用该集合所有子集的最小值 (min) 来表示；反之亦然。\n这为什么有用？在很多问题中，直接计算一个集合中多个随机变量的最大值的期望 (E[max]) 可能非常困难，因为这些变量往往不是独立的。然而，计算它们最小值的期望 (E[min]) 可能要简单得多。Min-Max 容斥搭起了两者之间的桥梁。\n基本公式设  是一个由数值（或随机变量）组成的有限集合。\n1. 用 min 表示 max集合  的最大值等于其所有非空子集的最小值的交替和：\n\n展开形式（以3个元素为例）：对于 :由于 ，上式即为：\n2. 用 max 表示 min集合  的最小值等于其所有非空子集的最大值的交替和：\n\n展开形式（以3个元素为例）：对于 :\n观察：这两个公式的结构与标准的容斥原理完全一致！\n证明过程我们来证明第一个公式：max(S) = ...。证明的思路是一种经典的组合计数思想：我们不直接证明等式两边相等，而是证明集合  中的每一个元素在右侧的式子中被计算的总系数，恰好使得最终结果为 max(S)。\n\n准备工作：将集合  的元素从大到小排序，设为 。那么，。我们的目标是证明右侧的交替和  的结果也等于 。\n\n分析贡献：考虑任意一个元素 。我们来计算它在整个式子中的总贡献，也就是它的最终系数。元素  会在哪些项  中出现？当且仅当  时， 才对这一项的值有贡献。\n\n确定条件： 的充要条件是：\n\n 必须在子集  中。\n所有比  小的元素 () 都不能在子集  中。\n 中的其他元素只能从比  大的元素 () 中选取。\n\n\n计算系数：符合上述条件的子集  必须由  和一个从 （这个集合有  个元素）中选出的子集  构成。即 。我们枚举  的大小，设 ，其中  可以从  到 。\n\n当  时，子集  的大小为 。\n从  个元素中选出  个元素构成 ，有  种选法。\n每一种这样的选法，对应的项是 。\n\n所以， 的总系数是所有这些情况的系数之和：\n\n应用二项式定理：这个求和式正是二项式定理  的一个特例。令 ，我们得到：\n\n分情况讨论：\n\n对于  (即  不是最大的元素 )：，所以 。这意味着，除了最大元素之外的所有元素  的最终系数都是0！它们对总和没有任何贡献。\n对于  (即  是最大的元素 )：，所以 。（在组合数学中，约定 ）这意味着，最大元素  的最终系数是 1。\n\n\n结论：在整个交替和中，只有  的系数是 1，其他所有元素的系数都是 0。所以，整个式子的值就是 。而 。证明完毕。\n\n\n期望形式 (最强大的应用)Min-Max 容斥最强大的地方在于它可以直接应用于期望。因为期望具有线性性 ()，我们可以将期望算子直接应用到公式的每一项。\n设  是一个由随机变量组成的集合 。\n\n这个公式是解决一类经典概率问题的杀手锏。\n经典应用：优惠券收集问题 (Coupon Collector’s Problem)问题：假设有  种不同的优惠券，每次购买商品会随机获得一种。问集齐所有  种优惠券所需购买商品次数的期望是多少？\n解法：\n\n定义随机变量：设  是获得第  种优惠券所需的购买次数。\n目标：我们要求的是集齐所有优惠券的次数，这等价于所有  中的最大值。即求 。\n困难点： 之间不是独立的，直接求  非常困难。\n应用 Min-Max 容斥：其中 。\n计算子问题 ： 是什么意思？它是指在子集  所代表的那些优惠券中，第一次获得其中任意一种所需的购买次数的期望。设 。这意味着我们的目标是获得这  种优惠券中的任何一种。在每次购买时，成功的概率（即抽到这  种中的一种）是 。这是一个典型的几何分布问题。对于成功概率为  的几何分布，其期望是 。所以，。\n代回原式：注意到  的值只取决于子集  的大小 ，而与具体是哪些元素无关。对于一个固定的 （），大小为  的子集  共有  个。所以，我们可以按子集大小  来分组求和：其中这就是优惠券收集问题的期望值的精确公式。（这个结果可以进一步化简，恰好等于 ，即  乘以调和级数，但 Min-Max 容斥直接给出了这个交替和形式的解）。\n\n扩展：k-th Min-Max 容斥Min-Max 容斥还有一个更广义的形式，可以用来求第  大（或第  小）的元素。\n设  表示集合  中第  大的元素。\n验证一下：当  时，求最大值（第1大）：。这与我们最初的 max 公式完全一致。\n同样，这个公式也适用于期望。\n总结\n核心功能：在 max 和 min 之间建立一个基于容斥原理的代数转换。\n结构：与标准容斥原理的公式结构完全相同。\n证明：通过分析每个元素在求和式中的总系数来证明，利用了二项式定理 。\n最强应用：期望形式 ，特别适用于求解多个非独立随机变量最大值的期望，能将一个困难问题分解为一系列简单的子问题。\n推广：存在 k-th Min-Max 形式，可以求解第  大/小的值。\n\n","tags":["数学"]},{"title":"费马小定理和逆元","url":"/2025/08/06/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86%E5%92%8C%E9%80%86%E5%85%83/","content":"费马小定理若  为素数，，则 。\n逆元引入我们知道，在实数域中，一个数 a 的倒数是 a⁻¹，因为 a * a⁻¹ = 1。除以一个数 b 就等价于乘以 b 的倒数，即 a / b = a * (b⁻¹)。\n在模运算的世界里，我们想做类似的事情。对于一个整数 a 和一个模数 p，我们想找到一个整数 x，使得 (a * x) % p = 1。如果找到了这样的 x，我们就称 x 是 a 在模 p 意义下的 乘法逆元，记作 a⁻¹。\n有了逆元，我们就可以在模 p 的意义下做除法了： (a / b) % p 就变成了 (a * b⁻¹) % p\n重要前提：a 在模 p 意义下存在逆元的充要条件是 a 和 p 互质，即 gcd(a, p) = 1。\n定义若 ，则称  为  的逆元\n当且仅当  时，逆元存在。\n快速幂法\n要求  为 素数\n\n根据费马小定理，。\n则 ，即  为  的逆元\nll mod;ll quick_power(ll a, ll k) {    ll res = 1;    while (k) {        if (k &amp; 1)            res = res * a % mod;        a = a * a % mod;        k &gt;&gt;= 1;    }    return res;}inline ll inv(ll x) {    return quick_power(x, mod-2);}\n\n线性方法记 inv[i] 为  的逆元。\n\n即 inv[i] = (p - p / i) * inv[p % i] % p\nll mod;ll inv[MAXN];void init(){    inv[1] = 1;    for (int i = 2; i &lt;= mod; ++i)        inv[i] = (mod - mod / i) * inv[mod % i] % p;}\n\n性质设  为  的逆元，则 \n卢卡斯定理\n要求  为 素数\n\n对于素数 ，有 \n即\nll mod;ll fact[MAX_MOD];  // 阶乘ll inv(int x);     // 逆元ll C(ll m, ll n) {    if (m &gt; mod || n &gt; mod)        return C(m / mod, n / mod) * C(m % mod, n % mod) % mod;    return fact[n] * inv(fact[m]) * inv(fact[n - m]) % mod;}\n","tags":["数学"]}]